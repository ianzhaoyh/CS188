Uniform Cost Search 需要确保对于同一个状态，如果发现更低代价的路径，应重新考虑（或者更新优先队列中的优先级）。而一旦你把状态加入了 seen 集合，就“封死”了对该状态更优路径的搜索。

​	•	在给出的测试图中，正确解应为 ['1:A->B', '0:B->C', '0:C->G']，说明 A→B 的花费是 1，而后续边花费为 0，总成本为 1；而直接从 A→G 的路径（看起来你返回了 ['0:A->G']）不应该被立刻返回，因为它的代价应当是 10，根据图中标注。如果你在生成 successor 时就检查或“冻结”了 G，那么程序可能以非最优（或错误的成本）路径返回结果